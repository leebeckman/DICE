<?xml version="1.0" encoding="UTF-8"?>
<!--
  ===================================================================
  Generic xa-datasource configuration,
  automatically generated by DeploymentService.
##
## author:  dimitris@jboss.org
## version: $Revision: 28245 $
  ===================================================================
-->
<datasources>
   <xa-datasource>
   
      <!-- Where to bind the datasource, under the "java:/" prefix -->
      <jndi-name>${jndi-name}</jndi-name>
#if($helper.isDefined(${use-java-context}))
      <!-- Setting this to false will bind the DataSource into global jndi -->
      <use-java-context>${use-java-context}</use-java-context>
#end    
#if(${track-connection-by-tx})
      <!-- All work on one tx will go through one connection -->
      <track-connection-by-tx/>
#end
      <!-- The fully qualifed name of the javax.sql.XADataSource implementation class -->
      <xa-datasource-class>${xa-datasource-class}</xa-datasource-class>
#if(${xa-datasource-properties})
      <!-- Pass arbitrary connection properties (string name/value pairs) to the XADataSource -->
#foreach($key in ${xa-datasource-properties.keySet()})
      <xa-datasource-property name="$key">${xa-datasource-properties.get($key)}</xa-datasource-property>
#end
#end
#if($helper.isDefined(${is-same-RM-override-value}))
      <!-- Force javax.transaction.xa.XAResource.isSameRM(XAResource) to return true or false -->
      <isSameRM-override-value>${is-same-RM-override-value}</isSameRM-override-value>
#end      
#if(${transaction-isolation})    
      <!-- The java.sql.Connection transaction isolation level to use -->
      <transaction-isolation>${transaction-isolation}</transaction-isolation>
#end    
#if(${user-name})
      <!-- Specifies the default username used when creating a new connection -->
      <user-name>${user-name}</user-name>
#end
#if(${password})
      <!-- Specifies the default password used when creating a new connection -->
      <password>${password}</password>
#end
#if(${security-config})

#if(${security-config.equalsIgnoreCase("APPLICATION-MANAGED-SECURITY")})
      <!-- App supplied parameters (such as from getConnection(user, pw)) -->
      <!-- are used to distinguish connections in the pool -->
      <application-managed-security/>
#elseif(${security-config.equalsIgnoreCase("SECURITY-DOMAIN")})
      <!-- Indicates that the Subject (from the security domain) -->
      <!-- is used to distinguish connections in the pool -->
      <security-domain>${security-domain}</security-domain>
#elseif(${security-config.equalsIgnoreCase("SECURITY-DOMAIN-AND-APPLICATION")})
      <!-- Indicates that either app suplied parameters or the -->
      <!-- Subject are used to distinguish connections in the pool -->
      <security-domain-and-application>${security-domain}</security-domain-and-application>
#end
#end
#if(${min-pool-size})

      <!-- The minimum number of connections a pool should hold -->
      <min-pool-size>${min-pool-size}</min-pool-size>
#end
#if(${max-pool-size})
      <!-- The maximum number of connections for a pool -->
      <max-pool-size>${max-pool-size}</max-pool-size>
#end
#if(${blocking-timeout-millis})
      <!-- The maximum time in milliseconds to block while waiting for a connection --> 
      <!-- before throwing an exception. Note that this blocks only while waiting -->
      <!-- for a permit for a connection, and will never throw an exception if -->
      <!-- creating a new connection takes an inordinately long time -->
      <blocking-timeout-millis>${blocking-timeout-millis}</blocking-timeout-millis>
#end
#if(${idle-timeout-minutes})
      <!-- The maximum time in minutes a connection may be idle before being closed -->
      <idle-timeout-minutes>${idle-timeout-minutes}</idle-timeout-minutes>
#end
#if(${no-tx-separate-pools})
      <!-- use separete pools for connection retrieved in a transaction -->
      <!-- and those retrieved outside a transaction -->
      <no-tx-separate-pools/>
#end
#if(${new-connection-sql})

      <!-- SQL statement to execute whenever a connection is added to the connection pool -->
      <new-connection-sql>${new-connection-sql}</new-connection-sql>
#end
#if(${check-valid-connection-sql})
      <!-- SQL statement to check validity of a pool connection -->
      <check-valid-connection-sql>${check-valid-connection-sql}</check-valid-connection-sql>
#end
#if(${valid-connection-checker-class-name})
      <!-- An org.jboss.resource.adapter.jdbc.ValidConnectionChecker -->
      <valid-connection-checker-class-name>${valid-connection-checker-class-name}</valid-connection-checker-class-name>
#end
#if(${exception-sorter-class-name})
      <!-- An org.jboss.resource.adapter.jdbc.ExceptionSorter -->
      <exception-sorter-class-name>${exception-sorter-class-name}</exception-sorter-class-name>
#end
#if(${track-statements})
      <!-- Whether to check for unclosed statements when a connection is -->
      <!-- returned to the pool, and result sets are closed when a statement -->
      <!-- is closed/return to the prepared statement cache -->
      <track-statements>${track-statements.toLowerCase()}</track-statements>
#end
#if(${prepared-statement-cache-size})
      <!-- The number of prepared statements per connection in an LRU cache -->
      <prepared-statement-cache-size>${prepared-statement-cache-size}</prepared-statement-cache-size>
#end
#if(${dependencies})

      <!-- ObjectNames of services the connection manager depends on -->
#foreach($dependency in ${dependencies})
      <depends>$dependency</depends>
#end
#end
#if(${type-mapping})

      <!-- Datasource/connection factory type-mapping -->
      <metadata>
         <type-mapping>${type-mapping}</type-mapping>
      </metadata>
#end

   </xa-datasource>
</datasources>