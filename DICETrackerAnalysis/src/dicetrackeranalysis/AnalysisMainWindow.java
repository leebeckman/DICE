/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * AnalysisMainWindow.java
 *
 * Created on 11-Mar-2012, 10:25:14 PM
 */

package dicetrackeranalysis;

import com.sun.java.swing.plaf.gtk.GTKLookAndFeel;
import edu.uci.ics.jung.algorithms.layout.CircleLayout;
import edu.uci.ics.jung.algorithms.layout.ISOMLayout;
import edu.uci.ics.jung.algorithms.layout.Layout;
import edu.uci.ics.jung.graph.DirectedSparseGraph;
import edu.uci.ics.jung.graph.DirectedSparseMultigraph;
import edu.uci.ics.jung.graph.Graph;
import edu.uci.ics.jung.graph.SparseMultigraph;
import edu.uci.ics.jung.graph.util.Context;
import edu.uci.ics.jung.visualization.BasicVisualizationServer;
import edu.uci.ics.jung.visualization.RenderContext.DirectedEdgeArrowPredicate;
import edu.uci.ics.jung.visualization.VisualizationViewer;
import edu.uci.ics.jung.visualization.control.DefaultModalGraphMouse;
import edu.uci.ics.jung.visualization.control.ModalGraphMouse;
import edu.uci.ics.jung.visualization.decorators.ToStringLabeller;
import edu.uci.ics.jung.visualization.util.ArrowFactory;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Shape;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.apache.commons.collections15.Transformer;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 *
 * @author lee
 */
public class AnalysisMainWindow extends javax.swing.JFrame {

    /** Creates new form AnalysisMainWindow */
    public AnalysisMainWindow() {
        try {
            UIManager.setLookAndFeel(new GTKLookAndFeel());
        } catch (UnsupportedLookAndFeelException ex) {
            Logger.getLogger(AnalysisMainWindow.class.getName()).log(Level.SEVERE, null, ex);
        }
        initComponents();

        jungViewPanel.setLayout(new FlowLayout());
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jungViewPanel = new javax.swing.JPanel();
        loadTracking = new javax.swing.JButton();
        fileNameField = new javax.swing.JTextField();
        testButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jungViewPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("JUNG View"));

        javax.swing.GroupLayout jungViewPanelLayout = new javax.swing.GroupLayout(jungViewPanel);
        jungViewPanel.setLayout(jungViewPanelLayout);
        jungViewPanelLayout.setHorizontalGroup(
            jungViewPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 775, Short.MAX_VALUE)
        );
        jungViewPanelLayout.setVerticalGroup(
            jungViewPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 492, Short.MAX_VALUE)
        );

        loadTracking.setText("Load Tracking Log");
        loadTracking.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadTrackingActionPerformed(evt);
            }
        });

        fileNameField.setEditable(false);

        testButton.setText("Test");
        testButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                testButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jungViewPanel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(loadTracking)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(fileNameField, javax.swing.GroupLayout.DEFAULT_SIZE, 594, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(testButton)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(loadTracking)
                    .addComponent(fileNameField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(testButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jungViewPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void loadTrackingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadTrackingActionPerformed
        JFileChooser chooser = new JFileChooser();
        int returnVal = chooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = chooser.getSelectedFile();
            try {
                // What to do with the file, e.g. display it in a TextArea
                FileReader reader = new FileReader(file.getAbsolutePath());
                fileNameField.setText(file.getAbsolutePath());

                DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
                Document doc = builder.parse(file);

                Element docRoot = doc.getDocumentElement();
                NodeList childNodes = docRoot.getChildNodes();
                /*
                 *  <taintlog type="RETURNING" reqHash="1175143947">
                 *      <location srcMethod="getString" srcClass="com.mysql.jdbc.ResultSet" destMethod="getString" destClass="com.mysql.jdbc.ResultSet" adviceType="AFTER" />
                 *      <taintedObject taintID="222891337" type="java.lang.String" value="First Forum">
                 *          <taintRecord>forum_db/jrf_forum/forumtitle#forum_db/jrf_forum/forumdesc#forum_db/jrf_forum/forumid#forum_db/jrf_forum/locked#</taintRecord>
                 *      </taintedObject>
                 *  </taintlog>
                 *
                 * Iterate through taintlogs,
                 * only accept reqHash=1175...,
                 * get location element, build link using src/dest Class/Method. Get taintedObject element, get taintID attribute.
                 * taintID flows over link, for now only consider one taintID.
                 * create edges, labelled with taint
                 */

                Graph<TaintNode, TaintEdge> g = new DirectedSparseGraph<TaintNode, TaintEdge>();

                String callingNodeName = null;
                String calledNodeName = null;
                String fieldNodeName = null;
                String taintID = null;
                String logType = null;

                HashMap<String, TaintNode> taintNodeMap = new HashMap<String, TaintNode>();

                // Iterate through taintlog records
                for (int i = 0; i < childNodes.getLength(); i++ ) {
                    if (childNodes.item(i) instanceof Element) {
                        Element taintLogElem = (Element) childNodes.item(i);
                        logType = taintLogElem.getAttribute("type");

                        NodeList taintLogChildNodes = taintLogElem.getChildNodes();

                        // Iterate over things like location, taintedObject, etc nodes
                        for (int j = 0; j < taintLogChildNodes.getLength(); j++) {
                            Element taintLogChildElem = (Element) taintLogChildNodes.item(j);
                            if (taintLogChildElem.getNodeName().equals("location")) {
                                callingNodeName = taintLogChildElem.getAttribute("srcClass") + ":" + taintLogChildElem.getAttribute("srcMethod");
                                calledNodeName = taintLogChildElem.getAttribute("destClass") + ":" + taintLogChildElem.getAttribute("destMethod");
                            }
                            else if (taintLogChildElem.getNodeName().equals("taintedObject")) {
                                taintID = taintLogChildElem.getAttribute("taintID");
                            }
                            else if (taintLogChildElem.getNodeName().equals("field")) {
                                fieldNodeName = taintLogChildElem.getAttribute("targetClass") + ":" + taintLogChildElem.getAttribute("targetField");
                            }
                        }

                        if (callingNodeName != null && calledNodeName != null && taintID != null && logType != null) {
                            if (!taintNodeMap.containsKey(callingNodeName))
                                taintNodeMap.put(callingNodeName, new TaintNode(callingNodeName));

                            if (!taintNodeMap.containsKey(calledNodeName))
                                taintNodeMap.put(calledNodeName, new TaintNode(calledNodeName));

                            if (fieldNodeName != null && !taintNodeMap.containsKey(fieldNodeName)) {
                                taintNodeMap.put(fieldNodeName, new TaintNode(fieldNodeName));
                            }

                            if (logType.equals("CALLING"))
                                g.addEdge(new TaintEdge(taintID, logType), taintNodeMap.get(callingNodeName), taintNodeMap.get(calledNodeName));
                            else if (logType.equals("RETURNING"))
                                g.addEdge(new TaintEdge(taintID, logType), taintNodeMap.get(calledNodeName), taintNodeMap.get(callingNodeName));
                            else if (logType.equals("FIELDSET")) {
                                g.addEdge(new TaintEdge(taintID, logType), taintNodeMap.get(calledNodeName), taintNodeMap.get(fieldNodeName));
                            }
                            else if (logType.equals("FIELDGET")) {
                                g.addEdge(new TaintEdge(taintID, logType), taintNodeMap.get(fieldNodeName), taintNodeMap.get(calledNodeName));
                            }

                            callingNodeName = null;
                            calledNodeName = null;
                            fieldNodeName = null;
                            taintID = null;
                        }

                        logType = null;
                    }
                }

//                float dash[] = {10.0f};
//                final Stroke callStroke = new BasicStroke(1.0f, BasicStroke.CAP_BUTT,
//                        BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
//                final Stroke returnStroke = new BasicStroke(1.0f, BasicStroke.CAP_BUTT,
//                        BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
//                final Stroke basicStroke = new BasicStroke(1.0f, BasicStroke.CAP_BUTT,
//                        BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
//                Transformer<TaintEdge, Stroke> edgeStrokeTransformer = new Transformer<TaintEdge, Stroke>() {
//                        public Stroke transform(TaintEdge s) {
//                            if (s.getType().equals("CALLING"))
//                                return callStroke;
//                            else if (s.getType().equals("RETURNING"))
//                                return returnStroke;
//                            else
//                                return basicStroke;
//                        }
//                    };
//                Transformer<Context<Graph<TaintNode, TaintEdge>, TaintEdge>, Shape> edgeArrowTransformer = new Transformer<Context<Graph<TaintNode, TaintEdge>, TaintEdge>, Shape>() {
//                    public Shape transform(Context<Graph<TaintNode, TaintEdge>, TaintEdge> i) {
//                        return ArrowFactory.getWedgeArrow(1f, 1f);
//                    }
//                };

                DirectedEdgeArrowPredicate<TaintNode, TaintEdge> arrowPred = new DirectedEdgeArrowPredicate<TaintNode, TaintEdge>();
                
                Layout<TaintNode, TaintEdge> layout = new ISOMLayout<TaintNode, TaintEdge>(g);
                layout.setSize(new Dimension(jungViewPanel.getWidth(), jungViewPanel.getHeight()));

                VisualizationViewer<TaintNode, TaintEdge> vs = new VisualizationViewer<TaintNode, TaintEdge>(layout);
                vs.setPreferredSize(new Dimension(jungViewPanel.getWidth(), jungViewPanel.getHeight()));
                vs.getRenderContext().setVertexLabelTransformer(new ToStringLabeller());
                vs.getRenderContext().setEdgeLabelTransformer(new ToStringLabeller());
//                vs.getRenderContext().setEdgeArrowTransformer(edgeArrowTransformer);
                vs.getRenderContext().setEdgeArrowPredicate(arrowPred);

                DefaultModalGraphMouse gm = new DefaultModalGraphMouse();
                gm.setMode(ModalGraphMouse.Mode.TRANSFORMING);
                vs.addKeyListener(gm.getModeKeyListener());
                vs.setGraphMouse(gm);

                jungViewPanel.add(vs);
                jungViewPanel.validate();
                jungViewPanel.repaint();

            } catch (SAXException ex) {
                Logger.getLogger(AnalysisMainWindow.class.getName()).log(Level.SEVERE, null, ex);
            } catch (ParserConfigurationException ex) {
                Logger.getLogger(AnalysisMainWindow.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IOException ex) {
                Logger.getLogger(AnalysisMainWindow.class.getName()).log(Level.SEVERE, null, ex);
            }
        } else {
            System.out.println("File access cancelled by user.");
        }
    }//GEN-LAST:event_loadTrackingActionPerformed

    private void testButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_testButtonActionPerformed
        // TODO add your handling code here:
        Graph<Integer, String> g = new SparseMultigraph<Integer, String>();
//        g.addVertex(1);
//        g.addVertex(2);
//        g.addVertex(3);
        g.addEdge("A", 1, 2);
        g.addEdge("B", 2, 3);
        g.addEdge("C", 3, 1);

        Layout<Integer, String> layout = new CircleLayout(g);
        layout.setSize(new Dimension(300, 300));
        BasicVisualizationServer<Integer, String> vs = new BasicVisualizationServer<Integer, String>(layout);
        vs.setPreferredSize(new Dimension(350, 350));


        jungViewPanel.add(vs);
        jungViewPanel.validate();
        jungViewPanel.repaint();
        System.out.println("added");

//        JFrame frame = new JFrame("simple view");
//        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
//        frame.getContentPane().add(vs);
//        frame.pack();
//        frame.setVisible(true);
    }//GEN-LAST:event_testButtonActionPerformed

    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new AnalysisMainWindow().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField fileNameField;
    private javax.swing.JPanel jungViewPanel;
    private javax.swing.JButton loadTracking;
    private javax.swing.JButton testButton;
    // End of variables declaration//GEN-END:variables

}
