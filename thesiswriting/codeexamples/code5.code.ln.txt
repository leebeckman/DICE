1:	/* Given a path which starts with a single Edge representing a read from
2:	 * persistent data, this recursively attempts to grow the path, checking
3:	 * if it can be found in flow graphs for other requests. If there are path
4:	 * matches in other requests, but these requests serve data to other users,
5:	 * the path represents an non-single user access and is abandoned.
6:	function findUserState(UserStateEdges, Path, FlowGraph, OtherRequestIDsToEdgeMap):
7:		if (Path.getLast() already visited):
8:			return
9:			
10:		ExpandPath = false
11:		
12:		foreach EdgeToFlowGraphMap in OtherRequestIDsToEdgeMap.values():
13:			foreach Edge in EdgeToFlowGraphMap.keys():
14:				MatchFlowGraph = EdgeToFlowGraphMap.get(Edge)
15:				/* Try to find the path in other flow graphs */
16:				if (matchPath(Path, MatchFlowGraph)):
17:					ExpandPath = true
18:					if (Edge.getRequestAddress() != Path.getLast().getRequestAddress()):
19:						return
20:			
21:		if (!ExpandPath)
22:			return
23:						
24:		UserStateEdges.add(Path.getLast())
25:		
26:		foreach NextEdge in FlowGraph.getNextEdges(Edge):
27:			NewPath = Path.copy()
28:			NewPath.add(NextEdge)
29:			findUserState(UserStateEdges, NewPath, FlowGraph, OtherRequestIDsToEdgeMap)
30:					
31:		
32:	/* Look for the same sequence of edges in Path in the TargetFlowGraph
33:	 */
34:	function matchPath(Path, TargetFlowGraph):
35:		FirstEdge = Path.getFirst()
36:		
37:		Matched = false
38:		foreach StartEdge in TargetFlowGraph.getEdges():
39:			/* Check if the edges share the same name for their start and end nodes */
40:			if (StartEdge.getStartNode.getName() == FirstEdge.getStartNode.getName() &&
41:				StartEdge.getEndNode.getName() == FirstEdge.getEndNode.getName()):
42:				PathPosition = 1
43:				CheckEdge = StartEdge
44:				
45:				while (PathPosition < Path.size()):
46:					NextCheckEdge = Path[PathPosition]
47:					Found = false
48:					foreach NextEdge in FlowGraph.getNeighborEdges(CheckEdge):
49:						if (NextEdge.getStartNode.getName() == NextCheckEdge.getStartNode.getName() &&
50:							NextEdge.getEndNode.getName() == NextCheckEdge.getStartNode.getName()):
51:							Found = true
52:							CheckEdge = NextEdge
53:							break
54:					
55:					if (Found):
56:						PathPosition++
57:					else
58:						break
59:				
60:				/* If we were able to get through the whole path, it exists in the TargetFlowGraph */
61:				if (PathPosition == Path.size())
62:					Match = true
63:					break
64:					
65:		return Matched
66:		
67:	/* Construct a map: {PersistentTaintID -> {RequestID -> {StartEdge -> FlowSubGraph}}}
68:	 * This map shows, for each persistent taint ID, which request graphs carry that taint,
69:	 * what are the earliest edges carrying that taint, and where does each bit of persistent
70:	 * taint flow from these points of origination (using an algorithm similar to the
71:	 * forwardSearch functions shown in other algorithms).
72:	 */
73:	function getMasterMap(PersistentTaintIDs, RequestSubGraphs):
74:	
75:	TG = taint trace graph, each node is a function or data source,
76:	   each edge is an event where tainted data is passed between nodes
77:	TT = taint ID tree, a tree which shows how tainted data is derived from
78:	   other tainted data. Taint IDs have as child nodes any taint IDs
79:	   which were immediately derived from them, such as a new tainted
80:	   string formed by concatenating with an already tainted string.
81:	
82:	RequestSubGraphs = getRequestSubGraphs(TG)
83:	
84:	ByRequestTaintIDs = {}
85:	PersistentTaintIDs = {}
86:	
87:	/* These are the same steps as done in the simple state finding
88:	 * algorithm above.
89:	 */
90:	foreach RequestSG in RequestSubGraphs:
91:	    ByRequestTaintIDs.add(getTaintIDSet(RequestSG))
92:	    
93:	for (i = 0; i < ByRequestTaintIDs.size(); i+=1):
94:		for (j = i+1; j < ByRequestTaintIDs.size(); j+=1):
95:			SetA = ByRequestTaintIDs[i]
96:			SetB = ByRequestTaintIDs[j]
97:		    PersistentTaintIDs.add(SetA \cap SetB)
98:	
99:	/* To save work, we remove any derived taint IDs. In tracing the
100:	 * path of tainted data from the original taint IDs, we will arrive 
101:	 * at the relevant derived taint IDs anyways.
102:	 */
103:	DerivedPersistentIDs = {}
104:	foreach PersistentTaintID in PersistentTaintIDs:
105:		DerivedPersistentIDs.add(TT.getAllChildrenOf(PersistentTaintID))
106:	
107:	PersistentTaintIDs.removeAll(DerivedPersistentIDs)
108:	
109:	MasterMap = getMasterMap(PersistentTaintIDs, RequestSubGraphs)
110:		
111:	foreach PersistentTaintID in MasterMap.keys():
112:		RequestIDToEdgeMap = MasterMap.get(PersistentTaintID)
113:	
114:		foreach RequestID in RequestIDToEdgeMap.keys():
115:			StartEdgeToFlowGraphMap = RequestIDToEdgeMap.get(RequestID)
116:			
117:			foreach StartEdge in StartEdgeToFlowGraphMap.keys():
118:				FlowGraph = StartEdgeToFlowGraphMap.get(StartEdge)
119:				/* This map is needed to compare the flow of taint in one
120:				 * request with the flow of the same taint in other requests.
121:				 */
122:				OtherRequestIDsToEdgeMap = RequestIDToEdgeMap.copy()
123:				OtherRequestIDsToEdgeMap.remove(RequestID)
124:				
125:				UserStateEdges = {}
126:				findUserState(UserStateEdges, {StartEdge}, FlowGraph, OtherRequestIDsToEdgeMap)
127:				
128:				if (UserStateEdges != {}):
129:					colorEdge(StartEdge)
130:					showGraphToUser(createGraphFromEdges(UserStateEdges))	
