// HELPER METHODS
/* Copy the InputGraph, but remove any edges carrying data which doesn't
 * have the input Variability. */
function pruneToVariability(InputGraph, Variability):
    
/* This function takes a fragmented taint graph as input (one can
 * find nodes such that there is no path between them), and extracts
 * every non-fragmented taint graph from it. */
function getConnectedSubGraphs(InputGraph):

/* Use the CallGraph data to check the overall execution time for the
 * TaintGraph edges. Return true if the time is over THRESHOLD. */
function checkOverCost(TaintGraph, CallGraph, THRESHOLD):

/* This uses the CallGraph to determine if the events indicated by
 * edges in Graph cause, through their descendent method calls, any 
 * events in the SideEffectGraph to occur. */
function getSideEffects(Graph, SideEffectGraph, CallGraph):
    Return any edges in SideEffectGraph which were caused by edges
	in Graph.

// EXECUTION START
TG = taint trace graph
CG = call graph, with all calls made during taint trace collection and
    their execution time

TGPredictable = pruneToVariability(TG, PREDICTABLE)
TGRandom = pruneToVariability(TG, RANDOM)

PredictableConnectedSubGraphs = getConnectedSubGraphs(TGPredictable)

foreach PredictableCS in PredictableConnectedSubGraphs:
    if (checkOverCost(PredictableCS, CG, ACCEPT_THRESHOLD)):
        /* Check that the execution of this graph does not result in the
         * flow of non-deterministic data */
        RandomSideEffects = getSideEffects(PredictableCS, TGRandom, CG)
        /* If there are side effects, it may be that they are cheap enough
         * to execute even when fetching from the cache. */
        if (checkOverCost(RandomSideEffects, CG, REJECT_THRESHOLD)):
            continue
        /* Present the graph to the user */
        colorOutputs(PredictableCS)
        colorInputs(PredictableCS)
        showGraphToUser(PredictableCS)
        /* Indicate the side effects, if any, for the user to handle. */
        showSideEffectsToUser(RandomSideEffects)