// HELPER METHODS

/* Given a path which starts with a single Edge representing a read from
 * persistent data, this recursively attempts to grow the path, checking
 * if it can be found in flow graphs for other requests. If there are path
 * matches in other requests, but these requests serve data to other users,
 * the path represents an non-single user access and is abandoned.
function findUserState(UserStateEdges, Path, FlowGraph, OtherRequestIDsToEdgeMap):
    if (Path.getLast() already visited):
        return
        
    ExpandPath = false
    
    foreach EdgeToFlowGraphMap in OtherRequestIDsToEdgeMap.values():
        foreach Edge in EdgeToFlowGraphMap.keys():
            MatchFlowGraph = EdgeToFlowGraphMap.get(Edge)
            /* Try to find the path in other flow graphs */
            if (matchPath(Path, MatchFlowGraph)):
                ExpandPath = true
                if (Edge.getRequestAddress() != Path.getLast().getRequestAddress()):
                    return
        
    if (!ExpandPath)
        return
                    
    UserStateEdges.add(Path.getLast())
    
    foreach NextEdge in FlowGraph.getNextEdges(Edge):
        NewPath = Path.copy()
        NewPath.add(NextEdge)
        findUserState(UserStateEdges, NewPath, FlowGraph, OtherRequestIDsToEdgeMap)
                
    
/* Look for the same sequence of edges in Path in the TargetFlowGraph
 */
function matchPath(Path, TargetFlowGraph):
    FirstEdge = Path.getFirst()
    
    Matched = false
    foreach StartEdge in TargetFlowGraph.getEdges():
        /* Check if the edges share the same name for their start and end nodes */
        if (StartEdge.getStartNode.getName() == FirstEdge.getStartNode.getName() &&
            StartEdge.getEndNode.getName() == FirstEdge.getEndNode.getName()):
            PathPosition = 1
            CheckEdge = StartEdge
            
            while (PathPosition < Path.size()):
                NextCheckEdge = Path[PathPosition]
                Found = false
                foreach NextEdge in FlowGraph.getNeighborEdges(CheckEdge):
                    if (NextEdge.getStartNode.getName() == NextCheckEdge.getStartNode.getName() &&
                        NextEdge.getEndNode.getName() == NextCheckEdge.getStartNode.getName()):
                        Found = true
                        CheckEdge = NextEdge
                        break
                
                if (Found):
                    PathPosition++
                else
                    break
            
            /* If we were able to get through the whole path, it exists in the TargetFlowGraph */
            if (PathPosition == Path.size())
                Match = true
                break
                
    return Matched
    
/* Construct a map: {PersistentTaintID -> {RequestID -> {StartEdge -> FlowSubGraph}}}
 * This map shows, for each persistent taint ID, which request graphs carry that taint,
 * what are the earliest edges carrying that taint, and where does each bit of persistent
 * taint flow from these points of origination (using an algorithm similar to the
 * forwardSearch functions shown in other algorithms).
 */
function getMasterMap(PersistentTaintIDs, RequestSubGraphs):

// EXECUTION START

TG = taint trace graph, each node is a function or data source,
   each edge is an event where tainted data is passed between nodes
TT = taint ID tree, a tree which shows how tainted data is derived from
   other tainted data. Taint IDs have as child nodes any taint IDs
   which were immediately derived from them, such as a new tainted
   string formed by concatenating with an already tainted string.

RequestSubGraphs = getRequestSubGraphs(TG)

ByRequestTaintIDs = {}
PersistentTaintIDs = {}

/* These are the same steps as done in the simple state finding
 * algorithm above.
 */
foreach RequestSG in RequestSubGraphs:
    ByRequestTaintIDs.add(getTaintIDSet(RequestSG))
    
for (i = 0; i < ByRequestTaintIDs.size(); i+=1):
    for (j = i+1; j < ByRequestTaintIDs.size(); j+=1):
        SetA = ByRequestTaintIDs[i]
        SetB = ByRequestTaintIDs[j]
        PersistentTaintIDs.add(SetA \cap SetB)

/* To save work, we remove any derived taint IDs. In tracing the
 * path of tainted data from the original taint IDs, we will arrive 
 * at the relevant derived taint IDs anyways.
 */
DerivedPersistentIDs = {}
foreach PersistentTaintID in PersistentTaintIDs:
    DerivedPersistentIDs.add(TT.getAllChildrenOf(PersistentTaintID))

PersistentTaintIDs.removeAll(DerivedPersistentIDs)

MasterMap = getMasterMap(PersistentTaintIDs, RequestSubGraphs)
    
foreach PersistentTaintID in MasterMap.keys():
    RequestIDToEdgeMap = MasterMap.get(PersistentTaintID)

    foreach RequestID in RequestIDToEdgeMap.keys():
        StartEdgeToFlowGraphMap = RequestIDToEdgeMap.get(RequestID)
        
        foreach StartEdge in StartEdgeToFlowGraphMap.keys():
            FlowGraph = StartEdgeToFlowGraphMap.get(StartEdge)
            /* This map is needed to compare the flow of taint in one
             * request with the flow of the same taint in other requests.
             */
            OtherRequestIDsToEdgeMap = RequestIDToEdgeMap.copy()
            OtherRequestIDsToEdgeMap.remove(RequestID)
            
            UserStateEdges = {}
            findUserState(UserStateEdges, {StartEdge}, FlowGraph, OtherRequestIDsToEdgeMap)
            
            if (UserStateEdges != {}):
                colorEdge(StartEdge)
                showGraphToUser(createGraphFromEdges(UserStateEdges))    
